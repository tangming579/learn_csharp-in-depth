## 第二章 C# 1所搭建的核心基础

### 2.1 委托

委托（delegate）相当于C语言中的函数指针。实际上，委托在某种程度上提供了间接的方法，换言之，不需要直接指定一个要执行的行为，而是将这个行为用某种方式 ”包含“ 在一个对象中。这个对象可以像其他任何对象那样使用。在该对象中，可以执行封装的操作。可以选择将委托类型看做只定义了一个方法的接口，将委托的实例看做看做实现了那个接口的一个对象。

开发者经常将事件和委托实例，或者将事件和委托类型字段混为一谈。但他们之间的差异十分大：事件不是委托类型的字段。之所以产生混淆，因为C#提供了一种简写方式，允许使用字段风格的事件（field-like event）。

“事件” 存在的首要理由和 “属性” 差不多——他们添加了一个封装层，实现了发布/订阅模式。通常，我们不希望其他代码能直接设置字段值；最起码也要先有所有者（owner）对新值进行验证。同样，我们通常不希望类外部的代码随意更改（或调用）一个事件的处理程序。

**对于委托的总结：**

- 委托封装了包含特殊返回类型和一组参数的行为，类似包含单一方法的接口；
- 委托类型声明中所描述的类型签名决定了那个方法可用于创建委托实例，同时决定了调用的签名；
- 为了创建委托实例，需要一个方法以及（对于实例方法来说）调用方法的目标；
- 委托实例是不易变的；
- 每个委托实例都包含一个调用列表——一个操作列表；
- 委托实例可以合并到一起，也可以从一个委托实例中删除另一个；
- 事件不是委托实例——只是成对的add/remove方法（类似于属性的取值方法/赋值方法）

### 2.2 类型系统的特征

- C# 1是静态类型的——编译器知道你能使用哪些成员
- C# 1是显式的——必须告诉编译器变量具有什么类型
- C# 1是安全的——除非存在真实的转换关系，否则不能将一种类型当做另一种类型
- 静态类型仍然不允许一个集合称为强类型的“字符串列表” 或者 “整数列表” ，除非针对不同的元素使用大量的重复代码；
- 方法覆盖和接口实现不允许协变性/逆变性

### 2.3 值类型和引用类型

